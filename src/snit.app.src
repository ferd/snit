{application, snit,
 [{description, "A SNI terminator library"},
  {vsn, "git"},
  {registered, []},
  {mod, {snit_app, []}},
  {applications,
   [kernel,
    stdlib,
    ssl,
    ranch
   ]},
  {env, [
    %% To compare cipher suites and make sure the OpenSSL name properly matches
    %% the internal Erlang name, run the following to generate a translation
    %% table in Erlang/OTP 18.0 to 18.2:
    %%
    %%   Table = lists:sort([{OpenSSL, [Erl]}
    %%                       || Erl <- ssl:cipher_suites(),
    %%                          Raw <- [ssl_cipher:suite(Erl)],
    %%                          OpenSSL <- [ssl_cipher:openssl_suite_name(Raw)]]).
    %%
    %% And the following from 18.3 to 20.x generate a backwards-compatible list:
    %%
    %%   Table = lists:sort([{OpenSSL,
    %%                         case Erl of
    %%                           {_,_,_} -> [Erl];
    %%                           {A,B,C,D} -> [{A,B,C},{A,B,C,D}]
    %%                          end}
    %%                      || Erl <- ssl:cipher_suites(),
    %%                         Raw <- [case Erl of
    %%                                   {_,_,_} -> ssl_cipher:suite(Erl);
    %%                                   {A,B,C,_} -> ssl_cipher:suite({A,B,C})
    %%                                 end],
    %%                         OpenSSL <- [ssl_cipher:openssl_suite_name(Raw)]])
    %%
    %% If any value is `false', the generation failed.
    %%
    %% For OTP-21, the internal format for ciphersuites changed to use maps,
    %% some SSL internal modules got shifted around, and so the new
    %% generation method looks like this:
    %%
    %%    SupportedVersions = [tlsv1, 'tlsv1.1', 'tlsv1.2'],
    %%    Suites = lists:usort(lists:append(
    %%        [ssl:cipher_suites(all, Vsn) || Vsn <- SupportedVersions]
    %%    )),
    %%    Table = [{Str, [S]}  || S <- Suites,
    %%                            Raw <- [ssl_cipher_format:suite(S)],
    %%                            Str <- [ssl_cipher_format:openssl_suite_name(Raw)],
    %%                            not is_map(Str)],
    %%
    %%
    %% Given a list of OpenSSL cipher suites, the configuration below can be
    %% generated by calling:
    %%
    %% [lists:keyfind(Suite, 1, Table) || Suite <- OpenSSLSuites].
    %% 
    %% Note that the OpenSSL translation layer is seen as there for backwards-
    %% compatibility reasons by the OTP team and may be deprecated
    %%
    {cipher_suites, [
      %% Dynamically populated from .app.src.script at build time
      %% based on either cipher_suites_21 or cipher_suites_18
    ]},
    {cipher_suites_21, [
        {"ECDHE-ECDSA-AES128-GCM-SHA256",
         [#{cipher => aes_128_gcm,key_exchange => ecdhe_ecdsa,
            mac => aead,prf => sha256}]},
        {"ECDHE-ECDSA-AES256-GCM-SHA384",
         [#{cipher => aes_256_gcm,key_exchange => ecdhe_ecdsa,
            mac => aead,prf => sha384}]},
        {"ECDHE-RSA-AES128-GCM-SHA256",
         [#{cipher => aes_128_gcm,key_exchange => ecdhe_rsa,mac => aead,
            prf => sha256}]},
        {"ECDHE-ECDSA-AES256-SHA384",
         [#{cipher => aes_256_cbc,key_exchange => ecdhe_ecdsa,
            mac => sha384,prf => sha384}]},
        {"ECDHE-RSA-AES256-SHA384",
         [#{cipher => aes_256_cbc,key_exchange => ecdhe_rsa,
            mac => sha384,prf => sha384}]},
        {"ECDHE-RSA-AES256-SHA",
         [#{cipher => aes_256_cbc,key_exchange => ecdhe_rsa,mac => sha,
            prf => default_prf}]},
        {"ECDHE-ECDSA-AES256-SHA",
         [#{cipher => aes_256_cbc,key_exchange => ecdhe_ecdsa,
            mac => sha,prf => default_prf}]},
        {"ECDHE-ECDSA-AES128-SHA256",
         [#{cipher => aes_128_cbc,key_exchange => ecdhe_ecdsa,
            mac => sha256,prf => sha256}]},
        {"ECDHE-RSA-AES128-SHA256",
         [#{cipher => aes_128_cbc,key_exchange => ecdhe_rsa,
            mac => sha256,prf => sha256}]},
        {"ECDHE-ECDSA-AES128-SHA",
         [#{cipher => aes_128_cbc,key_exchange => ecdhe_ecdsa,
            mac => sha,prf => default_prf}]},
        {"ECDHE-RSA-AES128-SHA",
         [#{cipher => aes_128_cbc,key_exchange => ecdhe_rsa,mac => sha,
            prf => default_prf}]},
        {"AES256-GCM-SHA384",
         [#{cipher => aes_256_gcm,key_exchange => rsa,mac => aead,
            prf => sha384}]},
        {"AES256-SHA256",
         [#{cipher => aes_256_cbc,key_exchange => rsa,mac => sha256,
            prf => default_prf}]},
        {"AES256-SHA",
         [#{cipher => aes_256_cbc,key_exchange => rsa,mac => sha,
            prf => default_prf}]},
        {"AES128-GCM-SHA256",
         [#{cipher => aes_128_gcm,key_exchange => rsa,mac => aead,
            prf => sha256}]},
        {"AES128-SHA256",
         [#{cipher => aes_128_cbc,key_exchange => rsa,mac => sha256,
            prf => default_prf}]},
        {"AES128-SHA",
         [#{cipher => aes_128_cbc,key_exchange => rsa,mac => sha,
            prf => default_prf}]}
    ]},
    {cipher_suites_18, [
        {"ECDHE-ECDSA-AES128-GCM-SHA256",
         [{ecdhe_ecdsa,aes_128_gcm,null}, {ecdhe_ecdsa,aes_128_gcm,null,sha256}]},
        {"ECDHE-ECDSA-AES256-GCM-SHA384",
         [{ecdhe_ecdsa,aes_256_gcm,null}, {ecdhe_ecdsa,aes_256_gcm,null,sha384}]},
        {"ECDHE-RSA-AES128-GCM-SHA256",
         [{ecdhe_rsa,aes_128_gcm,null}, {ecdhe_rsa,aes_128_gcm,null,sha256}]},
        % missing pre-18.3
        % {"ECDHE-RSA-AES256-GCM-SHA384",
        %  [{ecdhe_rsa,aes_256_gcm,null}, {ecdhe_rsa,aes_256_gcm,null,sha384}]}
        {"ECDHE-ECDSA-AES256-SHA384",
         [{ecdhe_ecdsa,aes_256_cbc,sha384}, {ecdhe_ecdsa,aes_256_cbc,sha384,sha384}]},
        {"ECDHE-RSA-AES256-SHA384",
         [{ecdhe_rsa,aes_256_cbc,sha384}, {ecdhe_rsa,aes_256_cbc,sha384,sha384}]},
        {"ECDHE-RSA-AES256-SHA",
         [{ecdhe_rsa,aes_256_cbc,sha}]},
        {"ECDHE-ECDSA-AES256-SHA",
         [{ecdhe_ecdsa,aes_256_cbc,sha}]},
        {"ECDHE-ECDSA-AES128-SHA256",
         [{ecdhe_ecdsa,aes_128_cbc,sha256}, {ecdhe_ecdsa,aes_128_cbc,sha256,sha256}]},
        {"ECDHE-RSA-AES128-SHA256",
         [{ecdhe_rsa,aes_128_cbc,sha256}, {ecdhe_rsa,aes_128_cbc,sha256,sha256}]},
        {"ECDHE-ECDSA-AES128-SHA",
         [{ecdhe_ecdsa,aes_128_cbc,sha}]},
        {"ECDHE-RSA-AES128-SHA",
         [{ecdhe_rsa,aes_128_cbc,sha}]},
        {"AES256-GCM-SHA384",
         [{rsa,aes_256_gcm,null},{rsa,aes_256_gcm,null,sha384}]},
        {"AES256-SHA256",
         [{rsa,aes_256_cbc,sha256}]},
        {"AES256-SHA",
         [{rsa,aes_256_cbc,sha}]},
        {"AES128-GCM-SHA256",
         [{rsa,aes_128_gcm,null},{rsa,aes_128_gcm,null,sha256}]},
        {"AES128-SHA256",
         [{rsa,aes_128_cbc,sha256}]},
        {"AES128-SHA",
         [{rsa,aes_128_cbc,sha}]}
    ]},
    %% This configuration is only loaded in OTP versions 19.2 and above (based
    %% on the availability of the `ssl:eccs/0' function, added in that release)
    %% since it was not supported before then.
    %%
    %% By default, the list of ECCs returned by Erlang/OTP favours strong curve
    %% with 512 bits, which turn out to have a significant impact on handshake
    %% time, nearly doubling it.
    %%
    %% By default, our "sane" configuration is the result of calling
    %% `ssl:eccs()' and then reordering the curves to favor 256 bit curves
    %% above 512 bit ones, and always picking `secp256r1' to be the first
    %% one considered, which matches what ELBs do. The favored order here is
    %% therefore 256 bits > 384 bits > Others in original order
    %%
    %% To generate a newer version of this config, run:
    %%
    %%     f(First), f(Priorities), f(PriFind), f(Sorted), f(ECCs),
    %%     First = [secp256r1], Priorities = [256,384],
    %%     PriFind = fun(X) -> -length(lists:takewhile(fun(Y) -> X =/= Y end, Priorities)) end,
    %%     Sorted = lists:sort(
    %%         fun({_, X}, {_, Y}) -> PriFind(X) >= PriFind(Y) end,
    %%         [{ECC, N} || ECC <- ssl:eccs(),
    %%                      N <- [case re:run(atom_to_list(ECC), "([0-9]{3})", [{capture, [1], list}]) of
    %%                                {match, [Bits]} -> list_to_integer(Bits);
    %%                                 _ -> undefined
    %%                            end]]),
    %%     ECCs = First ++ ([X || {X,_} <- Sorted] -- First).
    %%
    %%  The second line of the command contains the config for priorities of
    %%  curves and then just key sizes. Any undefined key size that is not
    %%  found in the `Priorities' list will be appended to the list in
    %%  its original order.
    {eccs, [secp256r1,brainpoolP256r1,secp256k1,brainpoolP384r1,
            secp384r1,brainpoolP512r1,sect571r1,sect571k1,secp521r1,
            sect409k1,sect409r1,sect283k1,sect283r1,sect239k1,sect233k1,
            sect233r1,secp224k1,secp224r1,sect193r1,sect193r2,secp192k1,
            secp192r1,sect163k1,sect163r1,sect163r2,secp160k1,secp160r1,
            secp160r2]}
  ]},
  {modules, []}
 ]}.
